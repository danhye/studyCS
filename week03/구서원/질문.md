## Q1

제네릭(Generic) 타입을 사용하는 이유와 장점에 대해 설명해 주세요.

-----

## 답변

### 1\. 제네릭을 사용하는 이유

제네릭은 \*\*타입을 일반화(Generalize)\*\*하는 것을 목표로 합니다. 즉, 특정 타입에 국한되지 않고 다양한 타입의 객체를 다룰 수 있도록 해줍니다. 이렇게 함으로써 **재사용성이 높은 클래스와 메서드**를 만들 수 있습니다.

예를 들어, 정수만 담는 리스트, 문자열만 담는 리스트 등 각각의 타입에 맞는 리스트 클래스를 만들 필요 없이, 하나의 `List` 클래스로 모든 타입의 데이터를 다룰 수 있게 되는 것입니다.

-----

### 2\. 제네릭의 장점

#### 1\) **타입 안전성(Type Safety) 강화** 🔒

컴파일 시점에 타입을 엄격하게 검사하여 **런타임 오류를 방지**합니다. 제네릭을 사용하지 않으면, 의도치 않은 타입의 객체가 컬렉션에 추가되어 나중에 `ClassCastException` 같은 오류가 발생할 수 있습니다.

  * **코드 예시 (제네릭 사용 전)**

    ```java
    import java.util.ArrayList;
    import java.util.List;

    public class NonGenericExample {
        public static void main(String[] args) {
            List items = new ArrayList(); // 제네릭 사용 안 함
            items.add("Hello");
            items.add(100); // 컴파일 에러가 발생하지 않음

            // 런타임에 ClassCastException 발생
            String item = (String) items.get(1); // 100을 String으로 형변환 시도
        }
    }
    ```

    위 코드는 컴파일은 성공하지만, 런타임에 형변환 오류가 발생합니다.

  * **코드 예시 (제네릭 사용 후)**

    ```java
    import java.util.ArrayList;
    import java.util.List;

    public class GenericExample {
        public static void main(String[] args) {
            List<String> items = new ArrayList<>(); // 제네릭 사용 (타입을 String으로 제한)
            items.add("Hello");
            // items.add(100); // 컴파일 에러 발생!

            String item = items.get(0); // 형변환이 필요 없음
        }
    }
    ```

    이 경우, `items.add(100)` 라인에서 컴파일 에러가 발생하므로, 런타임 오류를 사전에 방지할 수 있습니다.

#### 2\) **타입 캐스팅(Type Casting) 제거** 🔀

제네릭을 사용하면 컬렉션에서 객체를 꺼낼 때마다 번거로운 **형변환 과정이 필요 없습니다.** 이는 코드를 더 깔끔하고 읽기 쉽게 만들어 줍니다.

  * **코드 예시**
    ```java
    List<String> names = new ArrayList<>();
    names.add("Alice");
    names.add("Bob");

    // 제네릭 덕분에 명시적 형변환 없이 바로 String 타입으로 사용 가능
    String name = names.get(0);
    System.out.println(name.length()); // "Alice".length() 호출 가능
    ```

#### 3\) **코드 재사용성 향상** ♻️

하나의 클래스나 메서드를 정의하여 다양한 타입에 적용할 수 있습니다. 이는 코드의 양을 줄이고 유지보수를 용이하게 만듭니다.

  * **코드 예시**
    ```java
    // 제네릭 클래스
    class Box<T> {
        private T content;

        public void setContent(T content) {
            this.content = content;
        }

        public T getContent() {
            return content;
        }
    }

    // 메인 클래스
    public class Main {
        public static void main(String[] args) {
            // String 타입의 Box 사용
            Box<String> stringBox = new Box<>();
            stringBox.setContent("Hello World");
            String myString = stringBox.getContent();
            System.out.println(myString);

            // Integer 타입의 Box 사용
            Box<Integer> integerBox = new Box<>();
            integerBox.setContent(123);
            int myInteger = integerBox.getContent();
            System.out.println(myInteger);
        }
    }
    ```
    `Box` 클래스는 `T`라는 제네릭 타입 매개변수를 사용하여, `String`, `Integer` 등 어떤 타입의 객체든 담을 수 있는 재사용 가능한 구조를 제공합니다.















## Q2

**`List<List<Integer>> adjList1 = new ArrayList<>();`** 와 **`List<Integer>[] adjList2 = new ArrayList[V];`** 두 가지 방식으로 인접 리스트를 만들 때, 어떤 방식이 더 좋은 방식일까?

-----

## 답변

### 1\. 결론: `List<List<Integer>>` 방식이 더 좋다.

두 방식 모두 인접 리스트를 구현하는 데 사용될 수 있지만, **타입 안전성(Type Safety)** 측면에서 `List<List<Integer>>` 방식이 훨씬 우수하고 안정적.

-----

### 2\. 상세 설명 및 코드 예시

#### **방법 1: `List<List<Integer>>` (권장)**

이 방식은 **리스트 안에 리스트를 담는** 형태로, 자바의 제네릭 컬렉션을 활용하는 가장 일반적이고 안전한 방법.

  * **코드 예시**
    ```java
    import java.util.ArrayList;
    import java.util.List;

    // 노드 개수 V
    int V = 5;

    // 인접 리스트 생성
    List<List<Integer>> adjList1 = new ArrayList<>();

    // 각 노드에 대한 리스트 초기화
    for (int i = 0; i < V; i++) {
        adjList1.add(new ArrayList<>());
    }

    // 예시: 0번 노드와 1번 노드 연결
    adjList1.get(0).add(1);
    adjList1.get(1).add(0);
    ```
  * **제네릭과의 연관성: 타입 안정성 보장**
    `List<List<Integer>>`는 컴파일러에게 \*\*"이 리스트에는 반드시 `List<Integer>` 타입의 객체만 들어갈 수 있다"\*\*는 정보를 명시적으로 전달한다. 이 덕분에 `adjList1.add("Hello");`와 같은 코드를 작성하면 컴파일러가 바로 오류를 잡아내어 런타임에 발생할 수 있는 `ClassCastException`과 같은 문제를 사전에 방지할 수 있다.
    **제네릭의 가장 중요한 목표인 타입 안전성**

#### **방법 2: `List<Integer>[]` (권장하지 않음)**

이 방식은 **제네릭 타입의 배열을 생성**하는 방식.

  * **코드 예시**

    ```java
    import java.util.ArrayList;
    import java.util.List;

    // 노드 개수 V
    int V = 5;

    // 인접 리스트 생성 (경고 발생..노란줄)
    List<Integer>[] adjList2 = new ArrayList[V];

    // 각 노드에 대한 리스트 초기화
    for (int i = 0; i < V; i++) {
        adjList2[i] = new ArrayList<>();
    }

    // 예시: 0번 노드와 1번 노드 연결
    adjList2[0].add(1);
    adjList2[1].add(0);
    ```

  * **제네릭과의 연관성: 타입 소거(Type Erasure)와 충돌**
    `List<Integer>[] adjList2 = new ArrayList[V];` 코드에서 \*\*노란 밑줄(경고)\*\*이 발생하는 이유는 **자바의 제네릭과 배열의 특성이 충돌**하기 때문...

      * **제네릭**: 자바의 제네릭은 컴파일 시점에 `<Integer>`와 같은 타입 정보가 사라지는 **타입 소거** 방식으로 동작.
      * **배열**: 자바의 배열은 런타임에도 그 타입 정보(`String[]`, `Integer[]` 등)를 유지.

    이러한 차이 때문에 컴파일러는 `new ArrayList[V]`가 런타임에 어떤 타입의 리스트를 담게 될지 확신할 수 없게되고, 결과적으로 **`adjList2[0] = (List<Integer>) new ArrayList<String>();`** 와 같은 코드를 억지로 작성하면 컴파일러는 이를 막지 못하고 런타임에 \*\*`ClassCastException`\*\*이 발생할 수 있다. 컴파일러는 이러한 잠재적 위험을 경고하기 위해 노란 밑줄을 표시하는 것.

### 3\. 최종 비교

| 특징 | `List<List<Integer>>` | `List<Integer>[]` |
| :--- | :--- | :--- |
| **타입 안전성** | **O (완벽)** | **X (잠재적 문제)** |
| **초기화 방식** | 리스트를 추가하는 반복문 필요 (`adjList.add(new ArrayList<>());`) | 배열에 할당하는 반복문 필요 (`adjList[i] = new ArrayList<>();`) |
| **추천 여부** | **권장** | **권장하지 않음 (타입 안정성 문제)** |
