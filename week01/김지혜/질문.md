> ## 1. JDK 와 JRE 의 차이점은 무엇인가요? 
1. **JRE (Java Runtime Environment)** 
    - 자바 프로그램을 **“실행(run)”** 하기 위한 환경 
    - JVM + 라이브러리 (class 파일 실행에 필요한 것들) + 기타 실행 도구 포함
    
    ⇒ 자바 프로그램을 돌리는데 필요한 최소 환경 
    
2. **JDK (Java Development Kit)** 
    - 자바 프로그램을 **“개발(develop)”** 하고 실행할 수 있는 도구 모음 
    - JRE + (컴파일러 javc, 디버거 jdb, 문서 생성기 javadoc 등 개발용 툴) 
    
    ⇒ 자바 개발자라면 필수로 설치해야 하는 개발 키트


### 구조 그림 
```bash
JDK (개발용)
 ├── JRE (실행용)
 │    ├── JVM (Java Virtual Machine)
 │    └── Core Libraries (java.*, javax.*)
 └── Development Tools (javac, jdb, javadoc, etc.)
```


---

<br>

> ## 2. 리플렉션(Reflection) 이란 무엇인가요?

### 개념
자바 프로그램이 **실행 중(runtime)** 에 메타데이터에 접근하고 조작할 수 있게 해주는 기능 (즉, “코드 자체를 코드에서 다루는 것”) 

<details> 
    <summary> 컴파일</summary><br>
    
    자바 소스코드 (.java) 가 자바 컴파일러(javac) 에 의해 바이트코드(.class) 로 변환되는 시점
    
    → 코드가 맞는지 검사하는 단계 
</details>    
<br>
<details> 
    <summary> 런타임</summary><br>
    
    바이트코드(.class) 를 JVM 이 실행하는 실제 프로그램 동작 시점
    
    → 이 코드 실제로 돌아가면서 변수 값이 바뀌고 메서드가 실행되는 순간

</details>    
<br>
<details> 
    <summary> 메타데이터(metadata)</summary><br>
    
    클래스 자체에 대한 정보 
    
    ex. 클래스 이름, 필드 이름고 타입, 메서드 이름과 매개변수, 어노테이션 등

</details>    

### 리플렉션을 쓸 때와 쓰지 않았을 때의 차이점 

1. 리플렉션을 사용하지 않았을 때 (일반적인 경우)
    - 즉, 클래스 객체를 생성해서 해당 클래스의 메서드를 가져옴
    - 이런 경우는 반드시 어떤 클래스를 생성하고 어떤 메서드를 불러와야할지 명확하게 알아야함

```java
MyClass obj = new MyClass(); 
obj.method(); // 미리 타입이 결정되어 있어야 호출이 가능
```


2. 리플렉션을 사용한 경우
    - 포인트는 obj.method() 라고 직접 호출한게 아닌 문자열로 찾은 메서드를 실행시점에 호출!

```java
// 1. MyClass 라는 이름의 클래스를 실행중에 동적으로 로딩해서 Class 객체를 가져옴 
// 1-1. clazz 안에는 MyClass 의 설명서 (필드, 메서드, 생성자 정보) 가 들어있음 
Class<?> clazz = Class.forName("MyClass");
// 2. MyClass 안에 method 라는 이름의 public 메서드를 찾아서 method 객체로 반환 
Method m = clazz.getMethod("method");
// 3. MyClass 의 인스턴스를 실행중에 만들고 
// 3-1. 그 인스턴스에 대해 아까 찾아낸 method() 를 실행 
m.invoke(clazz.newInstance());
```


### 사용되는 예시 
- **어노테이션 기반 프로그래밍**
    - Spring → `@Autowired` 필드를 찾아서 객체 주입
        - Spring 컨테이너가 관리하는 Bean 을 자동으로 주입해주는 어노테이션
        - 내가 직접 new 로 객체를 만들지 않아도 스프링이 알아서 적절한 Bean 을 찾아 넣어줌


### 실제 경험한 예시 
- 엑셀 데이터를 받아올 때, 엑셀의 데이터가 여러 종류여서 DTO 가 여러 개로 구성된 것을 받아야 할 때가 있었다.
    - 이 때 요청으로 들어오는 엑셀 데이터가 어떤 종류일 지 몰라서 어떤 DTO 로 매핑해야할지 모르는 경우에 리플렉션을 사용했었다.
    - **동작원리**

    ```java
    public Object mapExcelRowToDto(Map<String, Object> rowData, String dtoClassName) throws Exception {
        // dtoClassName 예: "com.example.dto.UserDto"
        Class<?> clazz = Class.forName(dtoClassName);   // 런타임에 클래스 로딩
        Object dto = clazz.getDeclaredConstructor().newInstance(); // 객체 생성

        for (Map.Entry<String, Object> entry : rowData.entrySet()) {
            String fieldName = entry.getKey();    // 엑셀 컬럼명 = DTO 필드명
            Object value = entry.getValue();      // 엑셀 셀 값

            Field field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);            // private도 접근 가능
            field.set(dto, value);                // 값 주입
        }

        return dto;
    }

    ```        
    - 나는 리플렉션 자체를 사용했었는데, 대안으로 `Jackson`이라는 리플렉션 기반으로 매핑 라이브러리를 사용하면 훨씬 안전하고 빠르다고 한다.
    - Jackson : Json 직렬화 지만, 엑셀 → Map 변환 후 그대로 DTO 매핑 가능

---

### 참고 링크    
[Reflection(리플렉션) 에 대한 개념 및 단점, 그럼에도 쓰는 이유](https://lets-go-it.tistory.com/11 "아직은 null null 합니다 블로그로 이동")

