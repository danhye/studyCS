# 1주차: 디자인 패턴

## 회의 기록(클로바노트)
- https://clovanote.naver.com/s/LrMkDi7QcKUViibJVQxRxUS (09.09 화요일)
- https://clovanote.naver.com/s/CHEDHWAbXdFxSKdv5SYARTS (09.10 수요일)

## 📚 학습 범위

### 1.1 디자인 패턴
- 1.1.1 싱글톤 패턴
- 1.1.2 팩토리 패턴  
- 1.1.3 전략 패턴
- 1.1.4 옵저버 패턴
- 1.1.5 프록시 패턴과 프록시 서버
- 1.1.6 이터레이터 패턴
- 1.1.7 노출모듈 패턴
- 1.1.8 MVC 패턴
- 1.1.9 MVP 패턴
- 1.1.10 MVVM 패턴

## 🎯 학습 내용 정리
# 📚 CS 스터디 요약

---

## 🧑‍💻 싱글톤 패턴 (Singleton Pattern)
> 객체 인스턴스를 **하나만 생성**하여 사용하는 디자인 패턴.

### ✅ 장점
- 하나의 객체를 전역적으로 공유 → **메모리 부담 적음**

### ⚠️ 단점
- 하나의 인스턴스를 여러 모듈이 공유 → **TDD(테스트 주도 개발) 어려움**
- 모듈 간 **의존성 증가**

### 🛠 생성 방법
- **이른 초기화 (Eager Initialization)**  
  - 빌드 시 인스턴스 바로 생성  
  - 스레드 안전하지만, 미사용 시에도 메모리 차지
- **늦은 초기화 (Lazy Initialization)**  
  - 호출 시 인스턴스 생성  
  - 메모리 효율적이나 멀티스레드 환경에서 여러 인스턴스 생성 위험

### 🧵 멀티스레드 환경 문제 해결
- `synchronized`, **Double-Checked Locking** → 오버헤드 가능
- **권장 방법**: Bill Pugh 솔루션(Initialization-on-demand holder idiom), **Enum**

### 🔓 싱글톤 깨뜨리는 방법
- 직렬화/역직렬화 과정에서 새로운 객체 생성 가능
- 리플렉션 API로 private 생성자 호출 가능

---

## 🏭 팩토리 패턴 & 추상 팩토리 패턴

### 🏭 팩토리 메서드 패턴
- 객체 생성 전후 처리 로직 필요할 때 유용
- 기능 증가 시 생성 메서드도 많아짐

### 🏗 추상 팩토리 패턴
- **관련 객체들의 군(Family)**을 함께 생성
- 예: Mac/Windows용 버튼·체크박스 세트

### 🌱 스프링과의 관계
- `BeanFactory` → **팩토리 패턴**
- `FactoryBean` → **추상 팩토리 패턴**
- `BeanFactory`: 컨테이너의 최상위 개념  
- `FactoryBean`: 특정 빈(Bean) 생성 담당

---

## ♟️ 전략 패턴 (Strategy Pattern)
> **알고리즘(전략)을 런타임에 동적으로 선택/변경** 가능.

### 📌 사용 사례
- **OAuth 2.0 소셜 로그인**  
  - 구글, 카카오 등 로그인 방식 선택
  - Access Token(짧은 유효기간), Refresh Token(긴 유효기간) 관리
- **Java `Collections.sort()`**  
  - `Comparator`로 정렬 방식 동적 변경
- **Spring `Filter`**  
  - 요청 종류(권한 등)에 따라 처리 방식 다르게 적용

---

## 👀 옵저버 패턴 (Observer Pattern)
> 주체(Subject) 상태가 변하면 옵저버들에게 **자동 알림** 전달.

### 📝 개념
- 유튜버(주체)가 영상 업로드 → 구독자(옵저버)에게 알림 전송

### ⚠️ 전통적 문제
- 주체가 옵저버 목록을 직접 관리 → **OCP(Open-Closed Principle) 위반**

### 💡 개선 방법
- 프록시 객체 활용 → 주체 코드 수정 없이 상태 변화 감지  
- 이는 **AOP(관점 지향 프로그래밍)**과 유사

### 🔄 Pub/Sub과 차이
- 옵저버 패턴: 주체-옵저버 **강한 결합**
- Pub/Sub: 중간 매개체를 통한 **느슨한 결합**

---

## 🛡️ 프록시 패턴 (Proxy Pattern)
> 특정 객체 접근 제어를 위해 대리인(프록시) 제공.

### 🌍 리버스 프록시 (Reverse Proxy)
- 대표 예: **Nginx**
- 클라이언트 요청을 대신 받아 서버로 전달

### 주요 기능
- **캐싱**: 정적 파일 캐싱으로 서버 부하 감소
- **보안**: 특정 IP 차단/허용
- **로드 밸런싱**: 요청 분산
- **CORS 문제 해결**: 다른 Origin 간 요청 허용

---

## 🏛 MVC, MVP, MVVM 패턴

### 🎭 MVC (Model-View-Controller)
- 가장 전통적인 구조  
- **Model ↔ View 의존성** 존재 가능

### 🎤 MVP (Model-View-Presenter)
- **Presenter**가 Model-View 중재
- Model과 View 간 의존성 제거

### 🔄 MVVM (Model-View-ViewModel)
- ViewModel이 **데이터 바인딩** 제공  
- View 상태 자동 갱신  
- 모바일 환경에서 비대해지는 ViewController 문제 해결

---

# ⚠️ 잘못된 정보 및 보충 설명

## 1. 자바와 멀티스레딩
- ❌ "Java 21부터 멀티스레드 지원" → 잘못된 설명
- ✅ 자바는 **초기부터 멀티스레딩 지원**  
- Java 21의 **가상 스레드** = 더 가볍고 효율적인 동시성 처리

---

## 2. 자바의 값 전달 방식 (Call by Value)
- ✅ 자바는 **항상 Call by Value**
  - 기본형: 값 자체 복사
  - 참조형: **주소값 복사**
    - 메서드 내에서 원본 객체 내용 변경 가능
    - 원본 변수가 다른 객체를 가리키도록 변경은 불가능

---

## 3. 자바: 컴파일 언어 vs 인터프리터 언어
- ✅ 자바는 **컴파일 + 인터프리터 혼합형**
  1. `javac` → `.java` → `.class` (바이트코드 컴파일)
  2. JVM이 바이트코드 인터프리트
  3. **JIT 컴파일러**로 네이티브 코드 변환 → 성능 향상

---

## 4. 옵저버 패턴과 프록시
- 옵저버 패턴 개선 시 프록시 활용 가능  
- 스프링 AOP처럼 **횡단 관심사(cross-cutting concern)**를 분리하여  
  코드의 **유지보수성과 확장성** 향상

---


## 📅 일정

- **학습 기간**: 2025.09.01 ~ 2025.09.08
- **발표 일정**: 2025.09.09 (화) 18:30-19:30

---

**다음 주**: [2주차 - 프로그래밍 패러다임](../week02/README.md)
