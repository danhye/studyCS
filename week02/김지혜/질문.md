> ## 1. Record 란 ?

### 개념
**불변(Immutable) 데이터**를 간결하고 읽기 쉽게 담는 데 초점을 맞추고 있는 클래스 유형이다. 
⇒ 명확히 얘기하자면, 자바에서 도입된 언어 차원의 불변 데이터 전송 객체 문법


### 주요 특징 
- **불변성**
    - 일반적으로 변경할 수 있는 DTO 와는 다르게 한번 Record 를 만들면 그 데이터를 변경할 수 없다.
- **간결한 문법**
    - 필드만 선언하면 Java 가 자동으로 `생성자, Getter, equals(), hashCode(), toString()` 메서드를 만들어준다.
- **Setter 없음 (즉, 수정 불가능)**
    - Record 는 불변객체이기 때문에 Setter 메서드를 제공하지 않는다.
 

### Record 를 사용한 UserRecord 예시 (아래 DTO 와 비교)
```java
public record UserRecord(String name, int age, String email) {
}
```
이 한 줄만으로 Java 는 자동으로 다음을 생성해준다. 

- **생성자**: `new UserRecord(String name, int age, String email)`
- **각 필드에 대한 Getter 메서드**: `name(), age(), email()`
- 두 개의 **UserRecord 객체**를 비교하는 `equals()` 메서드
- 고유한 해시 코드를 생성하는 `hashCode()` 메서드
- 문자열 표현을 반환하는 `toString()` 메서드: <br>
   예를 들어, **UserRecord[name=Ashutosh, age=25, email=ashutosh@example.com]** 같은 형태로 출력 된다.

### Record 사용 이유 
- **불필요한 코드 감소**
    - 반복적으로 작성해야하는 `Getter` 메서드나 `equlas()` 메서드 같은 코드를 쓸 필요가 없다.
- **불변성 보장**
    - 객체가 생성된 후 데이터를 변경할 수 없게 만들어, 다중 스레드 환경에서 더 안전하게 사용할 수 있다.
- **명확한 의도**
    - Record 를 사용하면 해당 객체가 추가적인 동작이나 로직없이 데이터를 전달하기 위한 것임을 분명하게 알 수 있다.

## DTO vs Record
### 불변성(Immutability)

- **Record**
    - 기본적으로 불변성을 가지며, 한번 생성된 Record 인스턴스의 데이터는 변경 불가
    - 이런 불변성으로 인해 데이터는 일관성을 유지함
    - 추가적인 코드 없이도 스레드 안전(Thread-Safe) 하다.
- **DTO**
    - 일반적으로 가변성을 가지며, 객체가 생성된 후에도 필드를 변경할 수 있음
    - DTO 를 불변으로 만들려면 Setter 를 사용하지 않거나, final 필드를 사용하여 신중하게 설계해야함

### 보일러플레이트 코드(Boilerplate Code)

- **개념**
    - 프로그램의 핵심 로직과 직접적 관련은 없지만, 언어나 프레임워크의 요구사항 때문에 반복적으로 작성해야 하는 코드
    - ex. Getter/Setter, hashCode, toString ..
    
    ⇒ 없어도 되는데, 문법 / 환경 때문에 매번 써야하는 형식적인 코드 
    
- **Record**
    - 보일러플레이트 코드를 크게 줄일 수 있다.
- **DTO**
    - 직접 코드를 생성해줘야 한다.
    - Lombok 과 같은 도구를 사용하면 보일러플레이트 코드를 줄일 순 있다.
        - ex. `@Getter`, `@Setter` ..

### 커스터마이징

- **DTO**
    - 커스터마이징이 용이하다.
    - 데이터 유효성 검사, 데이터 변환 메서드 또는 비즈니스 로직을 추가할 수 있음
        - 물론 순수 DTO 에서는 권장되지 않는다.
- **Record**
    - 커스터마이징이 제한적이다.
    - 가볍고 불변성을 유지하도록 설계되어 있어, 내부 상태를 수정하거나 복잡한 로직을 쉽게 추가할 수 없다.
    - Record 에서 커스터마이징이 필요하다면 외부에서 보통 처리해야한다.
        - 즉, 데이터를 전달하는 데 집중

### 함수형 프로그래밍과의 연관성

함수형 프로그래밍의 핵심 원칙 중 하나는 불변성이다. 

- **Record**
    - 불변성에 맞게 설계 되어 있어, 함수형 프로그래밍이 강조하는 상태 변화 없는 데이터 구조와 잘맞다.
    - 불변 데이터를 전달할 수 있어 예측할 수 있고, 이해하기 쉬운 코드 스타일을 촉진함
- **DTO**
    - 유연하여 명령형 또는 객체 지향 프로그래밍 스타일에 적합
    - 가변성을 사용하면 함수형 프로그래밍에서 일반적으로 권장되지 않는 부작용이 발생할 수 있음


## 성능 고려사항

### 메모리 효율성

- 설계상 간단하므로 DTO 보다 메모리를 조금 덜 사용할 수 있다.
    - Record 가 직접 Getter, Setter .. 같은 메서드를 구현할 필요가 없기 때문이다.
    - 이러한 메서드들이 Java 컴파일러에 의해 자동으로 최적화 되어 생성되므로, 메모리 사용량이 줄어듦

### 불변성과 스레드 안전성

- Record 는 불변이므로, 특히 멀티 스레드 환경에서 성능상의 이점을 제공함
    - 불변은 **스레드 간에 공유 될 때 동기화나 잠금(Locking) 메커니즘이 필요하지 않다**
    - 이는 **스레드 간 경쟁(thread contention) 으로 성능이 저하되는 상황에서 성능을 향상**할 수 있음
- 가변은 멀티스레드 환경에서 사용할 경우, **스레드 안전성을 보장하기 위해 접근을 동기화**하거나 
다른 메커니즘을 사용해야 하므로 **성능에 추가적인 부담이 생기고 애플리케이션이 느려짐**

### 가비지 컬렉션

- DTO 와 Record 모두 일반적인 Java 객체(POJO) 이므로 동일한 가비지 컬렉션 처리에 따라 관리된다.
    - Record 가 더 간결하여, 메모리에 적은 객체가 생성되거나 유지될 수 있어, GC 이 조금 더 빠르게 이루어질 가능성이 있다.
        - 이는 대량의 데이터 객체를 처리하는 장기 실행어플리케이션에서 성능 향상에 기여함

### CPU 와 오버헤드

- Record 는 컴파일러에 의해 자동 생성되며 성능을 최적화하도록 설계되어 있음
    - 객체 생성, 메서드 호출, 비교작업에서 CPU 성능이 조금 더 향상 될 수 있음
- 복잡한 DTO 의 경우 수동으로 구현된 메서드에서 비효율성이 발생함

### 실제 성능

실제로는 DTO 와 Record 간의 성능 차이는 대부분의 애플리케이션에서 매우 적거나, 무시할 만한 수준임

- 그러나 대용량 데이터 처리, 높은 처리량을 요구하는 애플리케이션, 또는 리소스가 제한된 환경(ex. 모바일 or IoT 장치) 에서 눈에 띌 정도의 성능차이는 경험 가능

>**Record 는 상속을 받을 수 있을까?** 

정확하게는 Record 는 final 클래스로 다른 클래스를 상속 받을 수 없다. <br>
그러나 인터페이스 구현은 가능해서 implements 로 인터페이스를 받는 것은 가능하다.

### 참고 링크    
[DTO vs Record 뭘 써야할까?](https://yozm.wishket.com/magazine/detail/2814/ "요즘IT 블로그로 이동")

---

<br>

> ## 2. 오토박싱과 오토언박싱에 대해 설명해보세요. 

- **기본타입**
    - `int, long, float, double, boolean` 등
- **Wrapper클래스**
    - `Integer, Long, Float, Double, Boolean` 등

## 박싱과 언박싱

### 박싱

기본형 → 래퍼 클래스(Wrapper class) 로 감싸는 것

### 언박싱

래퍼 클래스(Wrapper class) → 기본 타입로 감싸는 것

```java
// 박싱
int i = 10;
Integer num = new Integer(i);

// 언박싱
Integer num = new Integer(10);
int i = num.intValue();
```

## 오토박싱(AutoBoxing) & 오토 언박싱(AutoUnBoxing) 
**JDK 1.5** 부터는 자바 컴파일러가 박싱과 언박싱이 필요한 상황에 자동으로 처리를 해준다. 
즉, 개발자가 `new Integer(10)` 같은 코드를 써주지 않아도 컴파일러가 자동으로 박싱 & 언박싱 해줌

```java
// 오토 박싱
int i = 10;
Integer num = i;

// 오토 언박싱
Integer num = new Integer(10);
int i = num;
```

### 주의점
- `NullPointerException` 위험
  - 아래의 코드에서는 컴파일러에서 자동으로 언박싱을 시도할 때 내부적으로 `obj.intValue()` 를 호출했을 것이고 <br>
    `null.intValue()` 가 되면서 메서드 호출 대상이 없게 되면서 JVM 에서 NullPointException 을 던진 것이다. 
```java
Integer obj = null; 
int x = obj;  // 오토 언박싱을 컴파일러에서 시도하면서 NullPointException 이 발생
```

### 성능 
편의성을 위해 오토 박싱과 오토 언박싱을 제공하고 있지만, 내부적으로 추가 연산 작업이 거치게 된다. 
따라서, 오토박싱 & 오토 언박싱이 일어나지 않도록 동일한 타입 연산이 이루어지도록 구현하는게 좋다.

**오토 박싱 연산** 
```java
public static void main(String[] args) {
    long t = System.currentTimeMillis();
    Long sum = 0L;
    for (long i = 0; i < 1000000; i++) {
        sum += i;
    }
    System.out.println("실행 시간: " + (System.currentTimeMillis() - t) + " ms");
}

// 실행 시간 : 19 ms
```
=> 명시적으로 다운캐스팅을 할 때는 어떻게 될까? → 그렇게 시간 차이가 크지 않다 ! 미세한 차이 ! 

**동일 타입 연산**
```java
public static void main(String[] args) {
    long t = System.currentTimeMillis();
    long sum = 0L;
    for (long i = 0; i < 1000000; i++) {
        sum += i;
    }
    System.out.println("실행 시간: " + (System.currentTimeMillis() - t) + " ms") ;
}

// 실행 시간 : 4 ms
```

### 컴파일러에서의 오토박싱 / 언박싱의 동작 원리
- 자바 소스 코드 → 컴파일러 (javac) → 바이트코드(.class)
- 이 때 컴파일러가 자동으로 `valueOf()` 나 `xxxValue()` 메서드 호출을 삽입해준다.
- 런타임(JVM) 이 아니라 **컴파일 타임**에서 변환이 일어난다.

---

# 추가 질문 사항 
> Q. 다른 타입일 경우 오토언박싱, 오토박싱이 이루어지나요?

결론부터 말하면 **오토언박싱(auto-unboxing)** 은 래퍼 클래스 -> 같은 타입의 기본형 변환만 지원한다. 
- Integer -> int
- Long -> long
- Double -> double

따라서 Long -> int 변수에 바로 넣으면 컴파일 에러가 발생한다. 
```java
Long l = 10L;
int i = l;   // ❌ 컴파일 에러
```

### 다른 타입일 때 오토 언박싱의 올바른 변환 방법 
1. 명시적 언박싱 + 캐스팅
```java
Long l = 10L;
// int i = (int)(long)l; // Long → long (언박싱) → int (형변환)
// 이것도 사실 long 으로는 자동으로 언박싱을 해주기 때문에 아래와 같이만 써도 된다.
int i = (int)l;
```
2. 메서드 사용
```java
Long l = 10L;
int i = l.intValue(); // 내부적으로 long → int 캐스팅 처리
```

**오토박싱(auto-boxing)** 은 ? => 에러가 나지 않는다. 
```java
int i = 10; 
Long l = i; // 실제 컴파일러는 Long l = Long.valueOf((long)i); 로 바꿔버린다. 
```

### 다른 타입일 때 오토 언박싱의 컴파일러 동작 과정 
1. i 는 int(기본형)
2. Long 은 long 의 래퍼 클래스
3. 자바는 int -> long 으로 묵시적 변환을 지원한다. (즉, 손실없이 long 으로 변환가능) 
4. Long 에 대입하려하면
   - int -> long (묵시적 형변환)
   - long -> Long (오토박싱)
이 2단계가 연쇄적으로 적용돼서 허용이 된다. <br>
=> 그래서 컴파일 에러 없이 정상 동작하게 된다. 

---



