# Iterator란 무엇인가요?

A. 직역하자면 '반복자'라는 뜻으로, 일반적으로는 컬렉션(리스트, 큐, 셋 등)에 들어있는 요소들을 **순차적으로 접근(순회)** 하기 위한 메서드, 인터페이스를 말한다.

---


## 자바에서 Iterator는?

1. **Iterable 인터페이스의 iterator() 메서드**

   * `Collection` 인터페이스는 `Iterable`을 상속한다.

     ```java
     public interface Collection<E> extends Iterable<E> { ... }
     ```
   * 그래서 `List`, `Set`, `Queue` 같은 컬렉션 클래스들은 전부 `iterator()` 메서드를 구현하게 된다.

2. **Collection과는 별개로 존재하는 Iterator 인터페이스**

   * `Iterator` 인터페이스는 `hasNext()`, `next()`, `remove()` 같은 메서드를 정의한다.
   * 이를 통해 어떤 컬렉션이든 동일한 방식으로 순회할 수 있도록 **표준화된 접근 방법**을 제공한다.

---

## Map은 왜 다를까?

* `Map`은 `Collection`을 상속하지 않기 때문에 **Iterable이 아님** → 따라서 `iterator()` 메서드도 직접 제공하지 않는다.
* 그래서 `Map`을 바로 순회할 수는 없고, **간접적으로** 다음과 같이 컬렉션 형태로 꺼내야 한다:

  * `keySet()` → 키를 Set으로 반환
  * `values()` → 값들을 Collection으로 반환
  * `entrySet()` → (key, value) 쌍을 Set으로 반환

즉, `Map` 자체는 향상된 for문으로 바로 돌릴 수 없지만,
아래처럼 `entrySet()`을 이용하면 가능하다:

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1); map.put("B", 2);

for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```

---

## Iterator 인터페이스의 역할

* 어떤 컬렉션이든 상관없이 `hasNext()`, `next()` 같은 **공통 메서드**로 순회할 수 있게 한다.
* 내부 구현 방식(배열, 링크드리스트, 트리 등)에 상관없이 동일한 인터페이스를 제공하기 때문에 **코드의 일관성**과 **재사용성**이 높아진다.
* `remove()` 메서드도 있지만, 자바 8 이후로는 잘 쓰이지 않고 안전하지 않은 경우가 많아 거의 사용되지 않는다.

---

## 예시 코드

```java
import java.util.Iterator;
import java.util.LinkedList;

public class Test {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("Lee"); 
        list.add("ekk"); 
        list.add("eww");

        // iterator() 메서드 → Iterator 인터페이스 구현 객체 반환
        Iterator<String> it = list.iterator();

        while (it.hasNext()) {
            System.out.print(it.next() + " ");
        }
    }
}
 
```

---

## 왜 필요할까?

* 배열처럼 순서가 명확한 구조는 `for`문으로 쉽게 순회되지만, 해시·트리·그래프처럼 저장 순서가 불확실한 자료구조는 **어떤 기준으로 순회할지(너비우선/깊이우선/정렬기준 등)** 정해야 한다.
* 이터레이터 패턴은 **순회 알고리즘을 반복자 객체로 분리**해서, 컬렉션 구현을 바꿔도 클라이언트 코드를 건드리지 않게 해준다.

---

## 구조(핵심 구성요소)

* **Aggregate (집합체 / 클라이언트가 가진 컬렉션 역할)**

  * `iterator()` 같은 팩토리 메서드를 제공해 반복자(Iterator)를 생성·반환한다.
* **ConcreteAggregate (구체 컬렉션 구현: ArrayList, LinkedList 등)**

  * 실제 데이터를 보관하고, 필요한 이터레이터 구현체를 생성해서 반환.
* **Iterator (인터페이스)**

  * `hasNext()`, `next()` (필요 시 `remove()`) 같은 순회 메서드를 정의.
* **ConcreteIterator (구체 반복자)**

  * 구체적인 순회 알고리즘(예: 저장순, 날짜순, 깊이우선 등)을 구현하고 컬렉션을 참조하여 순회한다.

```
Aggregate (iterator() 제공)
   └── ConcreteAggregate (실제 컬렉션)
          └── iterator() → ConcreteIterator (순회 알고리즘 구현)
Iterator 인터페이스: hasNext(), next() (표준 메서드)
```

---

## 자바와의 연계 포인트 (실무 관점)

* 자바 컬렉션 프레임워크(JCF)는 내부적으로 이 패턴을 활용해 **모든 컬렉션을 일관되게 순회**할 수 있도록 설계되어 있다.
* `Iterable` (혹은 `Collection`) 은 `iterator()` 메서드를 제공하도록 강제하는 쪽(집합체 역할), `Iterator` 인터페이스는 `hasNext()/next()` 규약을 제공하는 쪽으로 보면 패턴의 개념과 자연스럽게 대응된다. ([Inpa Dev ‍][1])

---

## 간단한 예제(아이디어 중심 — 게시판: 저장순 vs 날짜순)

아래 예시는 **순회 전략을 분리**해 `Board`가 두 가지 이터레이터(저장순, 날짜순)를 반환하는 구조를 보여준다.

```java
import java.time.LocalDate;
import java.util.*;

// 모델
class Post {
    String title;
    LocalDate date;
    public Post(String t, LocalDate d) { title = t; date = d; }
}

// 저장순 이터레이터 (자바 내부 iterator에 위임)
class ListPostIterator implements Iterator<Post> {
    private final Iterator<Post> itr;
    public ListPostIterator(List<Post> posts) { this.itr = posts.iterator(); }
    @Override public boolean hasNext() { return itr.hasNext(); }
    @Override public Post next() { return itr.next(); }
}

// 날짜순 이터레이터 (정렬 후 순회)
class DatePostIterator implements Iterator<Post> {
    private final Iterator<Post> itr;
    public DatePostIterator(List<Post> posts) {
        List<Post> copy = new ArrayList<>(posts);
        copy.sort(Comparator.comparing(p -> p.date)); // 날짜 기준 정렬
        this.itr = copy.iterator();
    }
    @Override public boolean hasNext() { return itr.hasNext(); }
    @Override public Post next() { return itr.next(); }
}

// 게시판: 필요한 이터레이터를 반환
class Board {
    private final List<Post> posts = new ArrayList<>();
    public void addPost(String t, LocalDate d) { posts.add(new Post(t, d)); }
    public Iterator<Post> getListPostIterator() { return new ListPostIterator(posts); }
    public Iterator<Post> getDatePostIterator() { return new DatePostIterator(posts); }
}

// 사용 예
public class Main {
    static void print(Iterator<Post> itr) {
        while (itr.hasNext()) {
            Post p = itr.next();
            System.out.println(p.title + " / " + p.date);
        }
    }
    public static void main(String[] args) {
        Board b = new Board();
        b.addPost("A", LocalDate.of(2020,8,30));
        b.addPost("B", LocalDate.of(2021,1,1));
        print(b.getListPostIterator());  // 저장순
        print(b.getDatePostIterator());  // 날짜순
    }
}
```

이렇게 하면 클라이언트는 순회 방법을 몰라도 `Iterator`만 받아 동일한 방식으로 순회할 수 있다. 전략을 바꾸려면 다른 `Iterator` 구현체만 받아오면 된다.

---

## 장단점 (요약)

**장점**

* 집합체의 내부 구조 노출을 막고, 순회 알고리즘을 교체·추가하기 쉬움.
* SRP(단일 책임), OCP(개방-폐쇄)의 이득을 얻음.

**단점**

* 클래스/파일 수가 늘어나 복잡도가 올라감.
* 단순한 경우 과도한 설계가 될 수 있어 언제 적용할지 판단 필요.

---

## 실무 팁

* 자바에서는 이미 `Iterator`/`Iterable`이 있으니 **직접 인터페이스를 다시 만들기보단** 표준 인터페이스를 활용해 구현(또는 위임)하는 편이 실용적이다.
https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EB%B0%98%EB%B3%B5%EC%9E%90Iterator-%ED%8C%A8%ED%84%B4-%EC%99%84%EB%B2%BD-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0


