> ## 1. 자바 컨테이너란? 
Java 에서 컨테이너(Container) 는 문맥에 따라 다른 의미로 쓰이고, 크게 3가지 범주로 정리할 수 있다. <br>
이는 개념적으로 겹치는 부분 없이 완전히 다른 용어이다. 

### 자바에서 '컨테이너' 의 의미 
**1. java.util 패키지의 컬렉션 프레임워크(List, Set, Map 등)**
- 의미 : 여기서 컨테이너란, **"데이터를 담는 그릇"**
- 예시 : `List`, `Set`, `Map`, `Queue` 등
- 특징
  - 객체들을 효율적으로 저장, 조회, 삭제 할 수 있는 자료구조
  - 제네릭을 통해 타입 안정성 제공
  - 내부적으로는 배열, 링크드리스트, 해시테이블, 트리 구조 등을 기반으로 동작
    
▶ 객체들을 저장하고 관리하기 위한 공간 이라는 개념으로, 자료구조 컨테이너를 제공한다. 

   
**2. AWT/Swing 의 Container 클래스(UI 계층에서의 컨테이너)**
- 의미 : GUI 프로그래밍에서 다른 컴포넌트(Component) 를 담는 컴포넌트
  - 컴포넌트 : 재사용이 가능한 각각의 독립된 모듈
- 위치: java.awt.Container는 Component를 상속하는 추상 클래스
- 특징
  - 다른 UI 컴포넌트(Button, Label 등) 를 포함할 수 있음
  - Panel, Frame, Dialog, Applet 등이 Container의 하위 클래스.
  - Swing에서도 JPanel, JFrame, JDialog 등이 동일 개념으로 사용됨.
    
▶ 그래픽 사용자 인터페이스(GUI) 에서 다른 컴포넌트(버튼, 텍스트, 필드 등) 를 담는 추상적인 부모 클래스로, <br>
   여러 컴포넌트를 그룹화하고 배치하는 역할을 한다. 

**3. 실행환경에서의 컨테이너 (Servlet / Spring Container 등) 
- 의미 : 실행환경에서 객체(Bean, Servlet 등) 의 생명주기와 관리를 담당하는 엔진
- 예시
  - Servlet Container : Tomcat, Jetty → 서블릿의 생성, 요청-응답 매핑, 스레드 관리
  - Spring Container : ApplicationContext, BeanFactory → 객체(Bean) 의 생성, 의존성 주입(DI), 라이프사이클 관리
- 특징
  -  개발자가 직접 객체를 new 하지 않고, 컨테이너가 대신 관리해줌(IoC)
  -  트랜잭션, 보안, 스레드 관리 등 부가 기능을 제공
  -  배포 환경과 밀접하게 연결됨 

<hr>

> ## 2. 각각 어떤 상황에서 HashMap과 TreeMap을 선택하나요?

## HashMap vs TreeMap

| **구분** | **HashMap** | **TreeMap** |
| --- | --- | --- |
| **저장 구조** | 해시 테이블 | 이진 탐색 트리(Red-Black Tree) |
| **정렬 여부** | 순서 보장 X (키 순서 없음) | 키 값에 따라 정렬(오름차순 기본) |
| **시간 복잡도** | 평균: O(1) (탐색, 삽입, 삭제) <br> 최악: O(n) | O(log n) (탐색, 삽입, 삭제) <br>→ 순서를 보장해서 HashMap 보다 오래 걸림  |
| **Null 허용** | Key: 1개 허용, Value: 여러 개 허용 | Key: Null 허용 X, Value: Null 허용 O |
| **메모리 사용량** | 상대적으로 적음 | 정렬을 유지하므로 HashMap보다 메모리/연산량 많음 |
| **사용 목적** | 빠른 조회, 단순 Key-Value 저장 | 정렬된 순회, 범위 검색, 순차적 접근 |

- **HashMap 이 Key 에 null 을 저장할 수 있는 이유**
    - HashMap 은 내부적으로 key 의 hashCode() 값을 기준으로 버킷(bucket) 을 찾는데 <br>
    null 은 메서드를 호출 할 수 없으니 (호출 시 NPE 발생해서) 특별하게 처리해준다.
        - **특별하게?**
            - map.put(null, value) 호출 시 → HashMap 은 0번 버킷(보통 index 0) 자리에 저장한다.
                
                ▶ 즉, null key 는 hash 계산 과정을 거치지 않고 특별 case 로 분기처리되어 0번 버킷 자리에 저장된다. 
                
        
        ```java
        // map.put 메서드 
        public V put(K key, V value) {
                return putVal(hash(key), key, value, false, true);
            }
        // key 값을 hash 값으로 계산하는 과정에서 
        // null 일 경우 0 으로 처리해주는 것을 볼 수 있다. 
        static final int hash(Object key) {
                int h;
                return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
            }
        ```
        
- **TreeMap 은 왜 Key 를 null 에 저장할 수 없을까?**
    - TreeMap 은 레드-블랙(Red-Black Tree) 구조를 사용해서 항상 정렬된 상태를 유지한다. <br>
    이때 정렬 기준은 `compareTo()` (키가 Comparable 구현체이다) 또는 Comparator 객체를 통해 결정된다.
    - **이 메서드나 객체로는 null 을 비교 연산 하지 못한다.**
        - `null.compareTo(x)` → NPE 발생 !
        - 혹은 `comparator.compare(null, x)` → 명시적으로 예외 발생가능
    
    ▶ 즉, 키를 삽입하려고 해도 “null 은 다른 키와 비교할 방법이 없다” 라는 근본적인 문제가 있다. 
    
    ```java
    // treeMap.put 메서드 내부 동작 
    private V put(K key, V value, boolean replaceOld) {
            Entry<K,V> t = root;
            if (t == null) {
                addEntryToEmptyMap(key, value);
                return null;
            }
            int cmp;
            Entry<K,V> parent;
            // split comparator and comparable paths
            Comparator<? super K> cpr = comparator;
            if (cpr != null) {
                // ... (로직) 
            } else {
                Objects.requireNonNull(key);
                @SuppressWarnings("unchecked")
                Comparable<? super K> k = (Comparable<? super K>) key;
                do {
                    parent = t;
                    cmp = k.compareTo(t.key);
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else {
                        V oldValue = t.value;
                        if (replaceOld || oldValue == null) {
                            t.value = value;
                        }
                        return oldValue;
                    }
                } while (t != null);
            }
            addEntry(key, value, parent, cmp < 0);
            return null;
        }
    
    // key 가 null 일 경우 requireNonNull 메서드 호출 
    public static <T> T requireNonNull(T obj) {
            if (obj == null)
                throw new NullPointerException(); // null 일 경우 NPE 발생시키는 것을 볼 수 있음 
            return obj;
        }
    ```
    

- **TreeMap**
    - 레드-블랙 트리 기반으로 키가 자동으로 정렬됨
    - **레드-블랙 트리 기반**이란?
        - 이진 탐색 트리의 일종
        - 노드에 빨강(Red) / 검정(Black) 색 속성을 두고, 노드 색과 회전을 통해 트리의 균형을 강제로 유지하는 자료구조
            - **왜 필요한가?**
                
                이진 탐색 트리는 삽입 순서에 따라 한쪽으로 치우쳐서 편향 트리가 될 수 있다. <br>
                → 최악의 경우 탐색이 O(n) 까지 느려진다. <br>
                하지만 레드-블랙 트리는 삽입/ 삭제 할 때마다 스스로 균형을 맞추는 트리라서 항상 O(log N) 성능을 유지할 수 있다. 
                
                - 이진 탐색 트리 : 각 노드를 기준으로 왼쪽 < 부모, 오른쪽 > 부모
    

<hr> 

### 추가 정보 

> 💡 **HashMap 은 왜 순서를 보장하지 못할까?** 

HashMap 은 내부적으로 배열 + 연결 리스트 / 트리 로 구성된 버킷(bucket) 배열을 가지고 있다. <br>
그리고 map.put 을 이용해서 데이터를 저장할 때 해시 함수를 통해 버킷 위치를 계산해서 넣기 때문에 **삽입한 순서를 유지하지 못한다.** <br>
▶ 정리하자면, key 의 `hashCode()`  를 구한 후, 내부 배열 크기와 연산을 해서 버킷 인덱스를 결정함


> 💡 **HashMap 의 동작흐름**

![image.png](attachment:eaae6f63-4ab5-4c42-b3da-e45fe1b311a7:image.png)

1. key 객체 → `hashCode()` 호출 → 정수 해시값 생성
2. 해시값을 배열의 인덱스로 변환(index = hash % capacity) 
3. 해당 인덱스 위치에 버킷(bucket) 이 존재 → 그 안에 (key, value) 쌍 저장 

▶ 즉, HashMap 은 배열 + 연결 구조로 만들어져 있고, 배열의 한 칸이 바로 “`버킷`” 이다.

- **버킷의 의미**
    - 버킷 = 배열의 슬롯 하나
    - 각 버킷은 같은 인덱스에 해시 충돌로 들어오는 여러 엔트리(Entry) 를 담을 수 있다.
    - JDK 8 기준
        - 충돌 개수 적으면 → `LinkedList` 로 엔트리들을 연결
        - 일정 개수 이상 충돌이 누적되면(기본 8개 이상) → 트리(Tree, Red-Black Tree 구조로 변환)


### 참고 링크  

[HashMap, TreeMap 차이를 알아보자](https://velog.io/@kimunche/HashMap-TreeMap-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84boza)
